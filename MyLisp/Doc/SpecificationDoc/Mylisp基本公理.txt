git https://github.com/yds086/MyLisp

1.原子概念
和lisp基本公理不同，mylisp中的原子携带两个值，一个是自身携带的值，一个是对自己的值的求值的结果，携带的值可以是列表，具体数值，以及对象引用（这和C++中的对象引用概念相同，用于对共享对象求值，而非拷贝对象进行求值），引用的对象可以是原子和列表。

如果一个原子，其值为列表，则对该原子求值就是对该列表的求值。
如果一个原子，其值为T NIL 字符串，则返回这符号名字为三种值的原子（整型，浮点暂时还没加进去），这样新生成的原子又能被赋值求值，产生新的数据代码对象。
如果一个原子，其名称是基本公理中的函数原子，如果这个函数原子没有提供原子求值器，则会求值失败（一般的基本公理不支持原子求值器只提供列表求值器，暂时只有StackRefLisp会考虑做成原子求值器）
如果一个原子，其没有被赋值过，则对其求值会按照自动名称绑定规则将其分配在栈上或者绑定到全局名称空间上，求值结果为自己的一个引用。

2.列表概念
列表和lisp基本公理不同，第一个参数表示原子，该原子可以是一个公理原子，也可以是一个原子列表，也可以是个形式上的列表(形式上的列表，非原子列表)，
如果是个形式列表则对列表递归求值直到返回值是一个原子（可能造成死循环）然后对该原子做引用列表求值。
如果第一个参数是一个原子，该原子是一个公理原子，则用公理原子对引用列表求值。
如果第一个参数是一个原子，该原子是一个列表的引用，则求值该列表作为引用列表的返回值，一般这个列表是一个栈，该栈会对引用列表做出求值。

3.栈以及全局名称空间概念
栈是用来运行时隔离原子符号定义的机制，目前将定义实现两种栈来分别应对宏以及函数的需要，函数需要完整的栈隔离机制，可以使用StackCode公理函数实现，宏使用局部栈技术，用StackCode_Part公理函数实现。

栈上的同名原子对象都只有一份栈拷贝，其他都已引用形式存在，栈上原子在没有被求值之前，他是不存在与任何命名空间的，只有被真正第一次求值时，才会被确定其名称空间，原子的命名空间确认顺序为本地栈-〉全局名称空间，如果没找到，那么就将原子名称空间确定为本级栈，如果找到则成为一个全局名称空间对象的引用(基本公理函数对象都挂在全局名称空间上，所以如果你的原子名称上是公理名称，那么用setref对其赋值，将会在栈上重载公理函数)。

StackCode_Part的栈原子，其符号确认顺序为 本地栈-〉上层栈-〉....递归到栈类型是StackCode的栈-〉全局符号空间，如果这个过程没找到，那么就将该原子名称空间确定为本级栈。

栈公理可能还需要一个强制在本级栈绑定或重载符号的一个配合公理。

4.基本公理函数（求值器）如下
(StackCode 代码列表)
在栈上对代码列表求值

(StackCode_Part 代码列表)
在栈上对代码列表求值,原子符号空间确定会回朔上层栈查询直到一个StackCode类型栈。

注意StackCode StackCode_Part返回值去意留形，去除栈上lisp的内容形态，比如返回一个lisp对象 (原子1 原子2)，仅仅在语义上返回这个lisp,如果原子1在本级栈上是个lisp对象（列表），那么lisp对象将被去除，返回的原子1将仅仅是一个未初始化的原子，因为如果带lisp值返回会将问题复杂化，很可能造成诡异的符号污染，后面考虑非lisp对象比如整数 字符串值的话可返回。


(StackRefLisp n)或者原子 StackRefLisp
功能：用于得到引用栈表达式的引用或者其列表中指定原子 
描述：如果是StackRefLisp原子，则返回一个栈的引用表达式引用，如果是列表方式求值则返回引用列表中指定位的原子，比如(StackRefLisp 0)返回引用栈第0个列表参数

(StackRefLispGetVal n)
和(StackRefLisp n)类似，不同的是StackRefLispGetVal返回的是在上层栈环境对引用参数求值的结果引用，这样就避免了在本栈需要对参数求值时造成的跨栈符号污染问题



(return x)或者一个被求值的原子return 
功能：栈返回
描述：如果是列表(return x)，则对x求值，并返回x的求值结果，如果是原子return 则直接返回栈，并不返回任何值，如果栈上没有以return的形式返回，则栈默认会将栈代码列表的求值结果返回。

(list `1 `1 `2 `4 )
对多有参数求值并新生成一个由参数求值结果组成的列表

(setref 列表或者原子 列表或者原子)
功能：申明引用
描述：对参数1 参数2求值（如果是对象引用则会解引用，也就是说不会有引用的引用存在），并将参数1的求值结果当做一个引用原子对象绑定到参数2的求值结果对象上，注意参数1的命名空间由其他求值器确定，如果没确定则按照自动对象名称绑定规则确定。

(setg 列表或者原子)
功能：将目标原子或求值的到的原子绑定创建到全局名称空间（已存在则绑定，不存在则创建）。
描述：参数1如果是列表（原子引用的列表，原子值是列表）则递归求值直到其为一个原子，如果是未初始化原子则不求值，将原子或者列表求值结果关联或者创建到全局名称空间，生命期目前在程序结束时释放

(sets 列表或者原子)
功能：将目标原子或求值的到的原子绑定创建到当前栈名称空间（已存在则绑定，不存在则创建）。
描述：参数1如果是列表（原子引用的列表，原子值是列表）则递归求值直到其为一个原子，如果是未初始化原子则不求值，将原子或者列表求值结果关联或者创建到当前栈名称空间，该函数为运行期递归宏做显式栈隔离很有用处。

注意使用setg sets时，目标原子必须在之前没有做过求值动作，或者被赋值为可求值为原子的列表或者列表引用，因为做过求值动作后，原子会在栈或者全局命名空间创建对象，如果目标原子已经确认过了名称空间，则绑定或者创建原子将会失败
关于引用于对象拷贝。
如果你的Lisp代码对象需要栈式隔离多执行序访问那么应该用setq做对象拷贝，如果只是线程函数内做数据赋值，那么建议用对象引用拷贝setref,因为这样不做对象拷贝，所以效率较高。

(setq `q `(1 2 3))) 
对参数1 2求值，对参数1递归求值直到其为一个原子，则为原子赋值为参数2的求值值，返回T或者Nil（自动确认）

其他引用lisp七大基本公理。

反引用 mylisp提供两种模式的反引用和一个引用式反引用，符号分别是,和;对应求值器为 (BackQuote x) (BackQuote_Stack x)，一般与引用符号连用，在引用被求值时反引用连带被求值,不同的是BackQuote在任何引用求值中都会被连带求值，BackQuote_Stack则只在自己最近的引用求值栈上被连带求值
比如
(list (car (list 1 2 3)))   求值结果为 (1)
`(list ,(car (list 1 2 3))) 求值结果为 (list 1)
`(list ;(car (list 1 2 3))) 求值结果为 (list 1)
``(list ,(car (list 1 2 3))) 求值结果为 `(list 1)
``(list ;(car (list 1 2 3))) 求值结果为 `(list ;(car (list 1 2 3)) 如果再次对结果求值则得到 (list 1)
`(a `;a)求值结果 (a `;a)
另外提供一个特别的反引用，隐式反引用 符号' 求值器(BackQuote_Quote x) 该求值不能单独存在，和;栈式反引用一样必须在最近的引用`求值的时候才会发生作用，但是其本身并不求值，只是把自己替换为真正的引用` 
起作用主要是为了使得栈式反引用;和最近的引用`求值时中间能加一个引用`，如果没有这个隐式引用存在，那么当需要生成引用的代码时，反引用将不能自由控制自己的求值时机
比如
`(a ';(cdr (list x y z))) 求值结果为 (a `(y z))
``(a ';(cdr (list x y z))) 求值结果为 `(a ';(cdr (list x y z)))
`(a `;(cdr (list x y z))) 求值结果为 (a `;(cdr (list x y z)))

5.辅助求值器
(RefLisp "..\Test\TestStack.txt")
RefLisp是个很特别的函数，对其求值就是对"..\Test\TestStack.txt"文件列表中的Lisp求值，并且求值后RefLisp所在的列表也被替换成"..\Test\TestStack.txt"中的lisp对象

(DebugLisp (需要调试的目标lisp列表) (日志打开项列表) (日志关闭项列表)) 
功能：打印目标lisp值以及开启关闭日志输出项
注意：其中 日志打开项列表和日志关闭项列表可以没有或者为空表，需要调试的目标lisp列表中lisp对象不被求值，只是引用打印。
可以开启或关闭的日志过滤项有：
求值错误
求值成功
所有求值过程
日志1 - 日志8

比如 (DebugLisp () (求值错误) (求值成功))  表示显示求值错误信息，关闭求值成功信息

6 数值计算类辅助求值器
(Mul 1 2 -3 4 5.0)
乘法
(Add 1 2 -3 4 5.0)
加法
(Mod 3 2.1)
模除

7.近期问题目标
做dsl,修复稳定栈方面的问题