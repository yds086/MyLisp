1.原子概念
和lisp基本公理不同，mylisp中的原子携带两个值，一个是自身携带的值，一个是对自己的值的求值的结果，携带的值可以是列表，具体数值，以及对象引用（这和C++中的对象引用概念相同，用于对共享对象求值，而非拷贝对象进行求值），引用的对象可以是原子和列表。

如果一个原子，其值为列表，则对该原子求值就是对该列表的求值。
如果一个原子，其值为T NIL 字符串，则返回这符号名字为三种值的原子（整型，浮点暂时还没加进去），这样新生成的原子又能被赋值求值，产生新的数据代码对象。
如果一个原子，其名称是基本公理中的函数原子，如果这个函数原子没有提供原子求值器，则会求值失败（一般的基本公理不支持原子求值器只提供列表求值器，暂时只有StackRefLisp会考虑做成原子求值器）

2.列表概念
列表和lisp基本公理不同，第一个参数表示函数原子，但可以是个列表，如果是个列表则对列表递归求值直到返回值是一个原子（可能造成死循环）然后对该原子做引用列表求值。

3.栈以及全局名称空间概念
栈是用来运行时隔离原子符号定义的机制，目前将定义实现两种栈来分别应对宏以及函数的需要，函数需要完整的栈隔离机制，可以使用StackCode公理函数实现，宏使用局部栈技术，用StackCode_Part公理函数实现。

栈上的同名原子对象都只有一份栈拷贝，其他都已引用形式存在，StackCode的栈原子，其符号确认顺序为本地栈-〉全局名称空间，如果没找到，那么就将原子名称空间确定为本级栈，如果找到则成为一个全局名称空间对象的引用(基本公理函数对象都挂在全局名称空间上，所以如果你的原子名称上是公理名称，那么用setref对其赋值，将会在栈上重载公理函数)。

StackCode_Part的栈原子，其符号确认顺序为 本地栈-〉上层栈-〉....递归到栈类型是StackCode的栈-〉全局符号空间，如果这个过程没找到，那么就将该原子名称空间确定为本级栈。

栈公理可能还需要一个强制在本级栈绑定或重载符号的一个配合公理。

4.基本公理函数如下
(StackCode 代码列表)
在栈上对代码列表求值

(StackCode_Part 代码列表)
在栈上对代码列表求值,这个暂时没完成

(StackRefLisp)
返回一个引用原子，引用值为栈引用lisp对象，是栈内访问上层引用栈的方式，该引用的对象输入上层栈，即便是对其求值，也是对上层栈对象的求值，公理还有些问题需要考虑完成

(list `1 `1 `2 `4 )
对多有参数求值并新生成一个由参数求值结果组成的列表

(setref 列表或者原子 列表或者原子)
引用赋值，对参数1 求值，参数2不求值（如果是对象引用则会解引用，也就是说不会有引用的引用存在），并将参数1的求值结果当做一个引用原子对象绑定到参数2的对象

(setg 列表或者原子)
将列表或者原子递归求值直到其为一个原子，将求值结果关联到全局名称空间，生命期实际上以栈为准，这个公理需要再斟酌考虑lisp对象生命期

(setq `q `(1 2 3))) 
对参数1 2求值，对参数1递归求值直到其为一个原子，则为原子赋值为参数2的求值值，返回T或者Nil

其他引用lisp七大基本公理。

反引用，列表引用融合后面再考虑