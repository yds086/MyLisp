git https://github.com/yds086/MyLisp

1.原子概念
和lisp基本公理不同，mylisp中的原子携带两个值，一个是自身携带的值，一个是对自己的值的求值的结果，携带的值可以是列表，具体数值，以及对象引用（这和C++中的对象引用概念相同，用于对共享对象求值，而非拷贝对象进行求值），引用的对象可以是原子和列表。

如果一个原子，其值为列表，则对该原子求值就是对该列表的求值。
如果一个原子，其值为T NIL 字符串，则返回这符号名字为三种值的原子（整型，浮点暂时还没加进去），这样新生成的原子又能被赋值求值，产生新的数据代码对象。
如果一个原子，其名称是基本公理中的函数原子，如果这个函数原子没有提供原子求值器，则会求值失败（一般的基本公理不支持原子求值器只提供列表求值器，暂时只有StackRefLisp会考虑做成原子求值器）
如果一个原子，其没有被赋值过，则对其求值会按照自动名称绑定规则将其分配在栈上或者绑定到全局名称空间上，求值结果为自己的一个引用。

2.列表概念
列表和lisp基本公理不同，第一个参数表示函数原子，但可以是个列表，如果是个列表则对列表递归求值直到返回值是一个原子（可能造成死循环）然后对该原子做引用列表求值。

3.栈以及全局名称空间概念
栈是用来运行时隔离原子符号定义的机制，目前将定义实现两种栈来分别应对宏以及函数的需要，函数需要完整的栈隔离机制，可以使用StackCode公理函数实现，宏使用局部栈技术，用StackCode_Part公理函数实现。

栈上的同名原子对象都只有一份栈拷贝，其他都已引用形式存在，栈上原子在没有被求值之前，他是不存在与任何命名空间的，只有被真正第一次求值时，才会被确定其名称空间，原子的命名空间确认顺序为本地栈-〉全局名称空间，如果没找到，那么就将原子名称空间确定为本级栈，如果找到则成为一个全局名称空间对象的引用(基本公理函数对象都挂在全局名称空间上，所以如果你的原子名称上是公理名称，那么用setref对其赋值，将会在栈上重载公理函数)。

StackCode_Part的栈原子，其符号确认顺序为 本地栈-〉上层栈-〉....递归到栈类型是StackCode的栈-〉全局符号空间，如果这个过程没找到，那么就将该原子名称空间确定为本级栈。

栈公理可能还需要一个强制在本级栈绑定或重载符号的一个配合公理。

4.基本公理函数（求值器）如下
(StackCode 代码列表)
在栈上对代码列表求值

(StackCode_Part 代码列表)
在栈上对代码列表求值,这个暂时没完成

(StackRefLisp)
返回一个引用原子，引用值为栈引用lisp对象，是栈内访问上层引用栈的方式，该引用的对象输入上层栈，即便是对其求值，也是对上层栈对象的求值，公理还有些问题需要考虑完成

(list `1 `1 `2 `4 )
对多有参数求值并新生成一个由参数求值结果组成的列表

(setref 列表或者原子 列表或者原子)
引用赋值，对参数1 参数2求值（如果是对象引用则会解引用，也就是说不会有引用的引用存在），并将参数1的求值结果当做一个引用原子对象绑定到参数2的求值结果对象上

(setg 列表或者原子)
功能：将目标原子绑定或创建到全局名称空间（已存在则绑定，不存在则创建）。
描述：参数1如果是列表或者递归求值直到其为一个原子，如果是原子则不求值，将原子或者列表求值结果强制关联或者创建到全局名称空间，生命期目前在程序结束时释放

(sets 列表或者原子)
功能：将目标原子绑定或创建到当前栈名称空间（已存在则绑定，不存在则创建）。
描述：参数1如果是列表或者递归求值直到其为一个原子，如果是原子则不求值，将原子或者列表求值结果强制关联或者创建到当前栈名称空间，该函数为运行期递归宏做显式栈隔离很有用处。

注意使用setg sets时，目标原子必须在之前没有做过求值动作，因为做过求值动作后，原子会在栈或者全局命名空间创建对象，如果目标原子已经确认过了名称空间，则绑定或者创建原子将会失败

(setq `q `(1 2 3))) 
对参数1 2求值，对参数1递归求值直到其为一个原子，则为原子赋值为参数2的求值值，返回T或者Nil（自动确认）

其他引用lisp七大基本公理。

反引用 mylisp提供两种模式的反引用，符号分别是,和;对应求值器为 (BackQuote x) (BackQuote_Stack x)，一般与引用符号连用，在引用被求值时反引用连带被求值,不同的是BackQuote在任何引用求值中都会被连带求值，BackQuote_Stack则只在自己最近的引用求值栈上被连带求值
比如
(list (car (list 1 2 3)))   求值结果为 (1)
`(list ,(car (list 1 2 3))) 求值结果为 (list 1)
`(list ;(car (list 1 2 3))) 求值结果为 (list 1)
``(list ,(car (list 1 2 3))) 求值结果为 `(list 1)
``(list ;(car (list 1 2 3))) 求值结果为 `(list ;(car (list 1 2 3)) 如果再次对结果求值则得到 (list 1)

5.辅助函数
(RefLisp "..\Test\TestStack.txt")
RefLisp是个很特别的函数，对其求值就是对"..\Test\TestStack.txt"文件列表中的Lisp求值，并且求值后RefLisp所在的列表也被替换成"..\Test\TestStack.txt"中的lisp对象



6.近期问题目标
反引用，列表引用融合后面再考虑